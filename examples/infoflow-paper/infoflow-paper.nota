%%%
import "@nota-lang/nota-theme-acm/dist/index.css"
import "@nota-lang/nota-theme-standalone/dist/index.css"
import bibtex from "./bibliography.bib"
import {rust} from "@codemirror/lang-rust"
import {cpp} from "@codemirror/lang-cpp"

let sysname = @Smallcaps{Flowistry};
%%%

@Title: Modular Information Flow through Ownership

%let stanford = @Affiliation{@Institution: Stanford University}
@Authors:
  @Author: @Name{Will Crichton} #stanford
  @Author: 
    @Name: Marco Patrignani
    @Affiliation:
      @Institution: University of Trento
  @Author: @Name{Maneesh Agrawala} #stanford
  @Author: @Name{Pat Hanrahan} #stanford

@Abstract:
  Statically analyzing information flow, or how data influences other data within a program, is a challenging task in imperative languages. Analyzing pointers and mutations requires access to a program's complete source. However, programs often use pre-compiled dependencies where only type signatures are available. We demonstrate that ownership types can be used to soundly and precisely analyze information flow through function calls given only their type signature. From this insight, we built Flowistry, a system for analyzing information flow in Rust, an ownership-based language. We prove the system's soundness as a form of noninterference using the Oxide formal model of Rust. Then we empirically evaluate the precision of Flowistry, showing that modular flows are identical to whole-program flows in 94% of cases drawn from large Rust codebases. We illustrate the applicability of Flowistry by using it to implement prototypes of a program slicer and an information flow control system.

@Section[label: "sec:intro"]: Introduction

Information flow describes how data influences other data within a program. Information flow has applications to security, such as information flow control @Ref{sabelfeld2003language}, and to developer tools, such as program slicing @Ref{weiser1984program}. Our goal is to build a practical system for analyzing information flow, meaning:

* **Applicable to common language features:** the language being analyzed  should support widely used features like pointers and in-place mutation. 
* **Zero configuration to run on existing code:** the analyzer must integrate with an existing language and existing unannotated programs. It must not require users to adopt a new language designed for information flow.
* **No dynamic analysis:** to reduce integration challenges and costs, the analyzer must be purely static --- no modifications to runtimes or binaries are needed.
* **Modular over dependencies:** programs may not have source available for dependencies. The analyzer must have reasonable precision without whole-program analysis.


As a case study on the challenges imposed by these requirements, consider analyzing the information that flows to the return value in this C++ function:

```cpp
// Copy elements 0 to max into a new vector
vector<int> copy_to(vector<int>& v, size_t max) {
  vector<int> v2; size_t i = 0;
  for (auto x(v.begin()); x != v.end(); ++x) {
    if (i == max) { break; }
    v2.push_back(*x); ++i;
  }
  return v2;
}
```

Here, a key flow is that `v2` is influenced by `v`: (1) `push_back` mutates `v2` with `*x` as input, and (2) `x` points to data within `v`. But how could an analyzer statically deduce these facts? For C++, the answer is *by looking at function implementations*. The implementation of `push_back` mutates `v2`, and the implementation of `begin` returns a pointer to data in `v`. 

However, analyzing such implementations violates our fourth requirement, since these functions may only have their type signature available. In C++, given only a function's type signature, not much can be inferred about its behavior, since the type system does not contain information relevant to pointer analysis.

Our key insight is that *ownership types* can be leveraged to modularly analyze pointers and mutation using only a function's type signature. Ownership has emerged from several intersecting lines of research on linear logic @Ref{girard1987linear}, class-based alias management @Ref{clarke1998ownership}, and region-based memory management @Ref{grossman2002region}. The fundamental law of ownership is that data cannot be simultaneously aliased and mutated. Ownership-based type systems enforce this law by tracking which entities own which data, allowing ownership to be transferred between entities, and flagging ownership violations like mutating immutably-borrowed data.

Today, the most popular ownership-based language is Rust. Consider the information flows in this Rust implementation of `copy_to`:

```rust
fn copy_to(v: &Vec<i32>, max: usize) -> Vec<i32> {
  let mut v2 = Vec::new();
  for (i, x) in v.iter().enumerate() {
    if i == max { break; }
    v2.push(*x);
  }
  return v2;
}
```

Focus on the two methods `push` and `iter`. For a `Vec<i32>`, these methods have the following type signatures:

```rust
fn push(&mut self, value: i32);
fn iter<'a>(&'a self) -> Iter<'a, i32>;
```

To determine that `push` mutates `v2`, we leverage *mutability modifiers*. All references in Rust are either immutable (i.e. the type is `&T`) or mutable (the type is `&mut T`). Therefore `iter` does not mutate `v` because it takes `&self` as input (excepting interior mutability, discussed in @Ref{sec:limitations}), while `push` may mutate `v2` because it takes `&mut self` as input.

To determine that `x` points to `v`, we leverage *lifetimes*. All references in Rust are annotated with a lifetime, either explicitly (such as `'a`) or implicitly. Shared lifetimes indicate aliasing: because `&self` in `iter` has lifetime `'a`, and because the returned `Iter` structure shares that lifetime, then we can determine that `Iter` may contain pointers to `self`.


Inspired by this insight, we built #sysname, a system for analyzing information flow in the safe subset of Rust programs. #sysname satisfies our four design criteria: (1) Rust supports pointers and mutation, (2) #sysname does not require any change to the Rust language or to Rust programs, (3) #sysname is a purely static analysis, and (4) Flowistry uses ownership types to analyze function calls without needing their definition. This paper presents a theoretical and empirical investigation into #sysname in five parts:

1. We provide a precise description of how #sysname computes information flow by embedding its definition within Oxide @Ref{weiss2019oxide}, a formal model of Rust (@Ref{sec:analysis}).
2. We prove the soundness of our information flow analysis as a form of noninterference (@Ref{sec:soundness}).
3. We describe the implementation of #sysname that bridges the theory of Oxide to the practicalities of Rust (@Ref{sec:implementation}).
4. We evaluate the precision of the modular analysis on a dataset of large Rust codebases, finding that modular flows are identical to whole-program flows in 94% of cases, and are on average 7% larger in the remaining cases (@Ref{sec:evaluation}).
5. We demonstrate the utility of #sysname by using it to prototype a program slicer and an IFC checker (@Ref{sec:applications}).

We conclude by presenting related work (@Ref{sec:rw}) and discussing future directions for #sysname (@Ref{sec:discussion}).
Due to space constraints, we omit many formal details, all auxiliary lemmas, and all proofs.
The interested reader can find them in the appendix.
#sysname and our applications of it are publicly available, open-source, MIT-licensed projects at [https://github.com/willcrichton/flowistry](https://github.com/willcrichton/flowistry).


@Section[label: "sec:analysis"]: Analysis

Inspired by the dependency calculus of Abadi et al. @Ref{abadi1999core}, our analysis represents information flow as a set of dependencies for each variable in a given function. The analysis is flow-sensitive, computing a different dependency set at each program location, and field-sensitive, distinguishing between dependencies for fields of a data structure.

While the analysis is implemented in and for Rust, our goal here is to provide a description of it that is both concise (for clarity of communication) and precise (for amenability to proof). We therefore base our description on Oxide @Ref{weiss2019oxide}, a formal model of Rust. At a high level, Oxide provides three ingredients: 

%%%
let hasType = (...args) => @span{#(args[0]) : #(args[1])};
%%%

1. A syntax of Rust-like programs with expressions $e$ and types $\tau$.
2. A type-checker, expressed with the judgment $\tc{\Sigma}{\Delta}{\Gamma}{e}{\tau}{\Gamma'}$ using the contexts $\Gamma$ for types and lifetimes, $\Delta$ for type variables, and $\Sigma$ for global functions.
3. An interpreter, expressed by a small-step operational semantics with the judgment $\stepsto{\sigma}{e}{\stepped{\sigma}}{e'}$ using $\sigma$ for a runtime stack.


TODOS for WILL:
* comment syntax
* fix headings, need to nest into `<section>`s
* labels on #-headers
* $-delimited tex
* `@{...}` fragments in JS
* `@fn` latex-like anon args
* newline at end of block should indent to current block
* auto-import `@codemirror/lang-*` repos if they're in the package.json


@References[bibtex]