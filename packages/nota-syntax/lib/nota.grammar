///////////// JAVASCRIPT nonterminals

@dialects { jsx, ts }

@precedence {
  nota @left,
  typeargs,
  typeMember,
  typePrefix,
  intersection @left,
  union @left,
  typeTernary @right,
  else @right,
  member,
  readonly,
  newArgs,
  call,
  taggedTemplate,
  prefix,
  postfix,
  typeof,
  exp @left,
  times @left,
  plus @left,
  shift @left,
  loop,
  rel @left,
  equal @left,
  bitOr @left,
  bitXor @left,
  bitAnd @left,
  and @left,
  or @left,
  ternary @right,
  assign @right,
  comma @left,
  statement @cut,
  predicate
}

statement[@isGroup=Statement] {
  ExportDeclaration |
  ImportDeclaration |
  ForStatement { kw<"for"> ckw<"await">? (ForSpec | ForInSpec | ForOfSpec) statement } |
  WhileStatement { kw<"while"> ParenthesizedExpression statement } |
  WithStatement { kw<"with"> ParenthesizedExpression statement } |
  DoStatement { kw<"do"> statement kw<"while"> ParenthesizedExpression semi } |
  IfStatement { kw<"if"> ParenthesizedExpression statement (!else kw<"else"> statement)? } |
  SwitchStatement { kw<"switch"> ParenthesizedExpression SwitchBody { lbrc switchItem* rbrc } } |
  TryStatement { kw<"try"> Block (kw<"catch"> (lparen pattern rparen)? Block)? (kw<"finally"> Block)? } |
  ReturnStatement { kw<"return"> (noSemi expression)? semi } |
  ThrowStatement { kw<"throw"> expression semi } |
  BreakStatement { kw<"break"> (noSemi Label)? semi } |
  ContinueStatement { kw<"continue"> (noSemi Label)? semi } |
  DebuggerStatement { kw<"debugger"> semi } |
  Block |
  LabeledStatement { Label ":" statement } |
  declaration |
  ExpressionStatement { expression semi } |
  ";"
}

ExportDeclaration {
  kw<"export"> Star (ckw<"as"> VariableName)? ckw<"from"> String semi |
  kw<"export"> kw<"default"> (FunctionDeclaration | ClassDeclaration | expression semi) |
  kw<"export"> tskw<"type">? declaration |
  kw<"export"> tskw<"type">? ExportGroup (ckw<"from"> String)? semi |
  kw<"export"> eq expression semi
}

ExportGroup {
  lbrc commaSep<VariableName (ckw<"as"> VariableName { word })?> rbrc
}

ImportDeclaration {
  kw<"import"> tskw<"type">? (Star ckw<"as"> VariableDefinition | commaSep<VariableDefinition | ImportGroup>)
    ckw<"from"> String semi |
  kw<"import"> String semi
}

ImportGroup {
  lbrc commaSep<tskw<"type">? (VariableDefinition | VariableName ckw<"as"> VariableDefinition)> rbrc
}

ForSpec {
  lparen
  (VariableDeclaration | expression ";" | ";") expression? ";" expression?
  rparen
}

forXSpec<op> {
  lparen
  ((kw<"let"> | kw<"var"> | kw<"const">) pattern | VariableName | MemberExpression | ArrayPattern | ObjectPattern)
  !loop op expression
  rparen
}

ForInSpec { forXSpec<kw<"in">> }
ForOfSpec { forXSpec<ckw<"of">> }

declaration {
  FunctionDeclaration |
  ClassDeclaration |
  VariableDeclaration |
  TypeAliasDeclaration |
  InterfaceDeclaration |
  EnumDeclaration |
  NamespaceDeclaration |
  AmbientDeclaration
}

FunctionDeclaration {
  async? !statement kw<"function"> Star? VariableDefinition? functionSignature Block
}

ClassDeclaration {
  !statement tskw<"abstract">? kw<"class"> VariableDefinition TypeParamList?
  (kw<"extends"> expression | TSExtends type)?
  (tskw<"implements"> commaSep1<type>)?
  ClassBody
}

ClassBody {
  lbrc (MethodDeclaration | PropertyDeclaration | StaticBlock | ";")* rbrc
}

privacy {
  @extend[@name=Privacy,@dialect=ts]<word, "public" | "private" | "protected">
}

privacyArg {
  @extend[@name=Privacy,@dialect=ts]<identifier, "public" | "private" | "protected">
}

MethodDeclaration[group=ClassItem] {
  privacy?
  (pkwMod<"static"> | tsPkwMod<"abstract">)?
  tsPkwMod<"override">?
  pkwMod<"async">?
  (pkwMod<"get"> | pkwMod<"set"> | Star)?
  (PropertyDefinition | PrivatePropertyDefinition)
  functionSignature
  Block
}

StaticBlock[group=ClassItem] {
  pkwMod<"static"> Block
}

PropertyDeclaration[group=ClassItem] {
  privacy?
  (pkwMod<"static"> | tsPkwMod<"abstract">)?
  pkwMod<"readonly">?
  (PropertyDefinition | PrivatePropertyDefinition)
  (Optional | LogicOp<"!">)?
  TypeAnnotation?
  (eq expressionNoComma)?
  semi
}

VariableDeclaration {
  (kw<"let"> | kw<"var"> | kw<"const">) commaSep1<patternAssignTyped> semi
}

TypeAliasDeclaration {
  tskw<"type"> TypeDefinition TypeParamList? eq type semi
}

InterfaceDeclaration {
  tskw<"interface"> TypeDefinition TypeParamList? (TSExtends type)? ObjectType
}

EnumDeclaration {
  kw<"const">? tskw<"enum"> TypeDefinition EnumBody { lbrc commaSep<PropertyName (eq expressionNoComma)?> rbrc }
}

NamespaceDeclaration {
  (tskw<"namespace"> | tskw<"module">) VariableDefinition ("." PropertyDefinition)* Block
}

AmbientDeclaration {
  tskw<"declare"> (
    VariableDeclaration |
    TypeAliasDeclaration |
    EnumDeclaration |
    InterfaceDeclaration |
    NamespaceDeclaration |
    GlobalDeclaration { tskw<"global"> Block } |
    ClassDeclaration {
      tskw<"abstract">? kw<"class"> VariableDefinition TypeParamList?
      (kw<"extends"> expression | TSExtends type)?
      (tskw<"implements"> commaSep1<type>)?
      ClassBody { lbrc (
        MethodDeclaration {
          privacy? (pkwMod<"static"> | tsPkwMod<"abstract">)? pkwMod<"async">? (pkwMod<"get"> | pkwMod<"set"> | Star)?
          (PropertyDefinition | PrivatePropertyDefinition) TypeParamList? ParamList (TypeAnnotation | TypePredicate) semi
        } |
        PropertyDeclaration |        
        IndexSignature
      )* rbrc }
    } |
    AmbientFunctionDeclaration {
      async? kw<"function"> Star? VariableDefinition? TypeParamList? ParamList (TypeAnnotation | TypePredicate) semi
    }
  )
}

pattern { VariableDefinition | ArrayPattern | ObjectPattern }

ArrayPattern { lbrkt commaSep<"..."? patternAssign> ~destructure rbrkt }

ObjectPattern { lbrc commaSep<PatternProperty> ~destructure rbrc }

patternAssign {
  pattern (eq expressionNoComma)?
}

TypeAnnotation { ":" type }

TypePredicate { ":" (VariableName | kw<"this">) !predicate tskw<"is"> type }

patternAssignTyped {
  pattern Optional? TypeAnnotation? (eq expressionNoComma)?
}

ParamList {
  lparen commaSep<"..." patternAssignTyped | privacyArg? tskw<"readonly">? patternAssignTyped> rparen
}

Block {
  !statement lbrc statement* rbrc
}

switchItem {
  CaseLabel { kw<"case"> expression ":" } |
  DefaultLabel { kw<"default"> ":" } |
  statement
}

expression[@isGroup=Expression] {
  expressionNoComma | SequenceExpression
}

SequenceExpression {
  expressionNoComma !comma ("," expressionNoComma)+
}

expressionNoComma {
  Number |
  String |
  TemplateString |
  VariableName |
  boolean |
  kw<"this"> |
  kw<"null"> |
  kw<"super"> |
  RegExp |
  ArrayExpression |
  ObjectExpression { lbrc commaSep<Property> ~destructure rbrc } |
  NewExpression { kw<"new"> expressionNoComma (!newArgs TypeArgList? ArgList)? } |
  UnaryExpression |
  ParenthesizedExpression |
  ClassExpression |
  FunctionExpression |
  ArrowFunction |
  MemberExpression |
  BinaryExpression |
  ConditionalExpression { expressionNoComma !ternary questionOp expressionNoComma LogicOp<":"> expressionNoComma } |
  AssignmentExpression |
  PostfixExpression { expressionNoComma !postfix (incdec | LogicOp<"!">) } |
  CallExpression { expressionNoComma !call TypeArgList? ArgList } |
  TaggedTemplateExpression { expressionNoComma !taggedTemplate TemplateString } |
  DynamicImport { kw<"import"> lparen expressionNoComma rparen } |
  ImportMeta { kw<"import"> "." PropertyName } |
  JSXElement |
  PrefixCast { tsAngleOpen type ~tsAngle ">" expressionNoComma } |
  ArrowFunction[@dynamicPrecedence=1] {
    TypeParamList { tsAngleOpen commaSep<typeParam> ">" } ParamList TypeAnnotation? "=>" (Block | expressionNoComma)
  } |
  AtCommand
}

ParenthesizedExpression { lparen expression rparen }

ArrayExpression {
  lbrkt commaSep1<"..."? expressionNoComma | ""> ~destructure rbrkt
}

propName { PropertyDefinition | lbrkt expression rbrkt | Number | String }

Property {
  pkwMod<"async">? (pkwMod<"get"> | pkwMod<"set"> | Star)? propName functionSignature Block |
  propName ~destructure (":" expressionNoComma)? |
  "..." expressionNoComma
}

PatternProperty {
  "..." patternAssign |
  (PropertyName | Number | String) ~destructure (":" pattern)? (eq expressionNoComma)?
}

ClassExpression {
  kw<"class"> VariableDefinition? (kw<"extends"> expression | TSExtends type)? ClassBody
}

functionSignature { TypeParamList? ParamList (TypeAnnotation | TypePredicate)? }

FunctionExpression {
  async? kw<"function"> Star? VariableDefinition? functionSignature Block
}

UnaryExpression {
  !prefix (ckw<"await"> | ckw<"yield"> | kw<"void"> | kw<"typeof"> | kw<"delete"> |
           LogicOp<"!"> | BitOp<"~"> | incdec | incdecPrefix | ArithOp<"+" | "-">)
  expressionNoComma
}

BinaryExpression {
  expressionNoComma !exp ArithOp<"**"> expressionNoComma |
  expressionNoComma !times (divide | ArithOp<pct> | ArithOp<"*">) expressionNoComma |
  expressionNoComma !plus ArithOp<"+" | "-"> expressionNoComma |
  expressionNoComma !shift BitOp<">>" ">"? | "<<"> expressionNoComma |
  expressionNoComma !rel (LessThan | CompareOp<"<=" | ">" eq?> | kw<"instanceof">) expressionNoComma |
  (expressionNoComma | PrivatePropertyName) !rel kw<"in"> expressionNoComma |
  expressionNoComma !rel ckw<"as"> (kw<"const"> | type) |
  expressionNoComma !equal CompareOp<"==" eq? | "!=" eq?> expressionNoComma |
  expressionNoComma !bitOr BitOp { "|" } expressionNoComma |
  expressionNoComma !bitXor BitOp<"^"> expressionNoComma |
  expressionNoComma !bitAnd BitOp { "&" } expressionNoComma |
  expressionNoComma !and LogicOp<"&&"> expressionNoComma |
  expressionNoComma !or LogicOp<"||" | "??"> expressionNoComma
}

AssignmentExpression {
  (VariableName | MemberExpression) !assign UpdateOp<($[+\-/%^] | "*" "*"? | "|" "|"? | "&" "&"? | "<<" | ">>" ">"? | "??") eq>
    expressionNoComma |
  (VariableName | MemberExpression | ArrayPattern | ObjectPattern) !assign eq expressionNoComma
}

MemberExpression {
  expressionNoComma !member (("." | "?.") (PropertyName | PrivatePropertyName) | lbrkt expression rbrkt)
}

ArgList {
  lparen commaSep<"..."? expressionNoComma> rparen
}

ArrowFunction {
  async? (ParamList { VariableDefinition } | ParamList TypeAnnotation?) "=>" (Block | expressionNoComma)
}

TypeArgList {
  @extend[@dialect=ts,@name="<"]<LessThan, "<"> commaSep<type> ">"
}

TypeParamList {
  "<" commaSep<typeParam> ">"
}

typeParam { TypeDefinition ~tsAngle (TSExtends type)? (eq type)? }

typeofMemberExpression[@name=MemberExpression] {
  VariableName !member (("." | "?.") PropertyName | lbrkt expression rbrkt)
}

type[@isGroup=Type] {
  ThisType { kw<"this"> } |
  LiteralType {
   ArithOp<"+" | "-">? Number |
   boolean |
   String
  } |
  TemplateType |
  VoidType { kw<"void"> } |
  TypeofType { kw<"typeof"> (VariableName | typeofMemberExpression) } |
  KeyofType { !typePrefix tskw<"keyof"> type } |
  UniqueType { !typePrefix tskw<"unique"> type } |
  ImportType { kw<"import"> lparen String rparen } |
  InferredType { tskw<"infer"> TypeName } |
  ParenthesizedType { lparen type rparen } |
  FunctionSignature { ParamTypeList "=>" type } |
  NewSignature { kw<"new"> ParamTypeList "=>" type } |
  IndexedType |
  TupleType { lbrkt commaSep<(Label ":")? type | "..." type> rbrkt } |
  ArrayType { type lbrkt rbrkt | type lbrkt rbrkt } |
  ReadonlyType { tskw<"readonly"> !readonly type } |
  ObjectType |
  UnionType { type !union LogicOp { "|" } type } |
  IntersectionType { type !intersection LogicOp { "&" } type } |
  ConditionalType { type !typeTernary questionOp ~arrow type LogicOp<":"> type } |
  ParameterizedType { (TypeName | IndexedType) !typeargs TypeArgList } |
  TypeName
}

IndexedType {
  type !typeMember ("." TypeName | lbrkt (String | Number) rbrkt)+
}

ObjectType {
  lbrc (
    MethodType |
    PropertyType |
    IndexSignature |
    CallSignature { ParamTypeList (TypeAnnotation | TypePredicate) semi } |
    NewSignature[@dynamicPrecedence=1] { @extend[@name=new]<word, "new"> ParamTypeList TypeAnnotation semi } |
    ";"
  )* rbrc
}

IndexSignature {
  pkwMod<"readonly">? lbrkt PropertyDefinition (TypeAnnotation | kw<"in"> type) rbrkt TypeAnnotation semi
}

MethodType {
  pkwMod<"async">?
  (pkwMod<"get"> | pkwMod<"set"> | Star)?
  PropertyDefinition
  functionSignature
  semi
}

PropertyType {
  (ArithOp<"+" | "-">? pkwMod<"readonly">)?
  PropertyDefinition
  (ArithOp<"+" | "-">? Optional)?
  TypeAnnotation
  semi
}  

ParamTypeList[@name=ParamList] {
  lparen commaSep<"..."? VariableDefinition ~arrow Optional? ~arrow TypeAnnotation?> rparen
}

@skip {} {
  TemplateString {
    templateStart (templateContent | templateExpr)* templateEnd
  }

  TemplateType {
    templateStart (templateContent | templateType)* templateEnd
  }
}

templateExpr { templateDollarBrace expression templateClosingBrace }

templateType { templateDollarBrace type templateClosingBrace }

@skip {} {
  JSXElement {
    JSXSelfClosingTag |
    (JSXOpenTag | JSXFragmentTag) (JSXText | JSXElement | JSXEscape)* JSXCloseTag
  }
}

JSXSelfClosingTag { JSXStartTag jsxElementName jsxAttribute* JSXSelfCloseEndTag }

JSXOpenTag { JSXStartTag jsxElementName jsxAttribute* JSXEndTag }

JSXFragmentTag { JSXStartTag JSXEndTag }

JSXCloseTag { JSXStartCloseTag jsxElementName? JSXEndTag }

jsxElementName {
  JSXIdentifier |
  JSXNamespacedName |
  JSXMemberExpression
}

JSXMemberExpression { (JSXMemberExpression | JSXIdentifier) "." JSXIdentifier }

JSXNamespacedName { (JSXIdentifier | JSXNamespacedName) ":" JSXIdentifier }

jsxAttribute {
  JSXSpreadAttribute { lbrc "..." expression rbrc } |
  JSXAttribute { (JSXIdentifier | JSXNamespacedName) (eq jsxAttributeValue)? }
}

jsxAttributeValue {
  JSXAttributeValue |
  JSXEscape { lbrc expression rbrc } |
  JSXElement
}

JSXEscape { lbrc "..."? expression rbrc }

commaSep<content> {
  "" | content ("," content?)*
}

commaSep1<content> {
  content ("," content)*
}

// Keywords

kw<term> { @specialize[@name={term}]<identifier, term> }

// Contextual keywords

ckw<term> { @extend[@name={term}]<identifier, term> }

tskw<term> { @extend[@name={term},@dialect=ts]<identifier, term> }

async { @extend[@name=async]<identifier, "async"> }

// Contextual keyword in property context

pkwMod<term> { @extend[@name={term}]<word, term> }

tsPkwMod<term> { @extend[@name={term},@dialect=ts]<word, term> }

semi { ";" | insertSemi }

boolean { @specialize[@name=BooleanLiteral]<identifier, "true" | "false"> }

Star { "*" }

VariableName { identifier ~arrow }

VariableDefinition { identifier ~arrow }

TypeDefinition { identifier }

TypeName { identifier ~arrow }

Label { identifier }

PropertyName { word }

PropertyDefinition { word }

PrivatePropertyName { privateIdentifier }

PrivatePropertyDefinition { privateIdentifier }

Optional { "?" }

questionOp[@name=LogicOp] { "?" }

@skip { spaces | newline | LineComment | BlockComment }

///////////// NOTA nonterminals

@top Document { TextBody }
  
TextBody { TextToken* }

TextToken { Text | NotaNewline | Command }

Command { PctCommand | HashCommand | AtCommand }

NotaExpression { expressionNoComma }
NotaStatement { statement+ }

PctCommand { pct lparen NotaStatement rparen }
HashCommand { hash CommandName (ArgCodeAnon | ArgText)* }
AtCommand { 
  at CommandName ArgCodeNamed* ArgText*
| at ArgText+ 
}

CommandName { VariableName | Number | !nota lparen NotaExpression rparen }

ArgCodeNamed { !nota lbrkt VariableName (eq NotaExpression)? rbrkt }

ArgCodeAnon { !nota lbrkt NotaExpression rbrkt }

ArgText { !nota lbrc TextBody rbrc | lverb VerbatimText rverb }


///////////// TOKENS

@context context from "./nota_tokens.ts"
@external tokens notaNewline from "./nota_tokens.ts" { NotaNewline }
@external tokens text from "./nota_tokens.ts" { Text }
@external tokens verbatim from "./nota_tokens.ts" { VerbatimText }

@external specialize { identifier } tsExtends from "./js_tokens" { TSExtends[@name=extends] }

@external tokens noSemicolon from "./js_tokens" { noSemi }

@external tokens incdecToken from "./js_tokens" {
 incdec[@name=ArithOp],
 incdecPrefix[@name=ArithOp]
}

@external tokens template from "./js_tokens" {
  templateContent,
  templateDollarBrace,
  templateEnd
}

@tokens {    
  /////// NOTA tokens
  pct[@export] { "%" }
  at[@export] { "@" }
  hash[@export] { "#" }
  lverb[@export] { "|{" }
  rverb[@export] { "}|" }
  lparen[@export] { "(" }
  rparen[@export] { ")" }
  lbrc[@export] { "{" }
  rbrc[@export] { "}" }
  lbrkt[@export] { "[" }
  rbrkt[@export] { "]" }
  eq[@export] { "=" }
    
  ////// JS tokens
  spaces[@export] { $[\u0009 \u000b\u00a0\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]+ }
  newline[@export] { $[\r\n\u2028\u2029] }

  LineComment { "//" ![\n]* }

  // FIXME split into multiple tokens
  BlockComment { "/*" blockCommentRest }

  blockCommentRest { ![*] blockCommentRest | "*" blockCommentAfterStar }

  blockCommentAfterStar { "/" | "*" blockCommentAfterStar | ![/*] blockCommentRest }

  divide[@name=ArithOp] { "/" }

  @precedence { BlockComment, LineComment, divide }

  @precedence { BlockComment, LineComment, RegExp }

  identifierChar { std.asciiLetter | $[_$\u{a1}-\u{10ffff}] }

  word { identifierChar (identifierChar | std.digit)* }

  identifier { word }

  privateIdentifier { hash word }

  @precedence { spaces, newline, identifier }

  @precedence { spaces, newline, JSXIdentifier }

  @precedence { spaces, newline, word }

  Number {
    (std.digit ("_" | std.digit)* ("." ("_" | std.digit)*)? | "." std.digit ("_" | std.digit)*)
      (("e" | "E") ("+" | "-")? ("_" | std.digit)+)? |
    std.digit ("_" | std.digit)* "n" |
    "0x" (std.digit | $[a-fA-F] | "_")+ "n"? |
    "0b" $[01_]+ "n"? |
    "0o" $[0-7_]+ "n"?
  }

  String {
    '"' (![\\\n"] | "\\" _)* '"'? |
    "'" (![\\\n'] | "\\" _)* "'"?
  }

  templateStart { "`" }

  templateClosingBrace { rbrc }

  ArithOp<expr> { expr }
  LogicOp<expr> { expr }
  BitOp<expr> { expr }
  CompareOp<expr> { expr }
  UpdateOp<expr> { expr }

  RegExp { "/" (![/\\\n[] | "\\" ![\n] | lbrkt (![\n\\\]] | "\\" ![\n])* rbrkt)+ ("/" $[gimsuy]*)? }

  LessThan[@name=CompareOp] { "<" }

  "..."[@name=Spread]
  "=>"[@name=Arrow]

  "?." "." "," ";" ":"

  JSXIdentifier { identifierChar (identifierChar | std.digit | "-")* }

  JSXAttributeValue { '"' !["]* '"' | "'" ![']* "'" }

  JSXStartTag[@dialect=jsx] { "<" }

  JSXStartCloseTag { "</" }

  JSXEndTag { ">" }

  JSXSelfCloseEndTag { "/>" }

  JSXText { ![<{]+ }

  tsAngleOpen[@dialect=ts] { "<" }

  @precedence { JSXStartTag, tsAngleOpen }
}

@external tokens insertSemicolon from "./js_tokens" { insertSemi }

@detectDelim